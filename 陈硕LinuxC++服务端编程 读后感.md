## 值语义与对象语义

* **什么是值语义？**
  将值语义拷贝一份后，拷贝份与原本的那份没有直接联系。 
  int double ，C++标准库里的 vector<>. map<>. string 都属与值语义。

* **什么是对象语义？**

  对象语义值的是面向对象语义下的对象，其拷贝是被禁止的、没有意义的。 比如 Thread、TcpConnection，拷贝他们并不会产生新线程，新 tcp 连接。  Java 里面的语义都属于 对象语义。



* **值语义与对象语义的生命周期问题** ？
  值语义通常放在栈上或者 作为对象的成员变量。 因此 其内存管理都比较简单，我们不用为其发愁。

  对象语义由于禁止拷贝，我们只能使用指针来引用它。这就带来了内存管理的麻烦。  我们可以使用智能指针，来进行内存管理。  同时，智能指针 也具有值语义。

  

* **值语义语标准库**

>《陈硕》
>
>C++ 要求凡是能放入标准容器的类型必须具有值语义。准确地说：type 必须是 SGIAssignable concept 的 model。但是，由 于C++ 编译器会为 class 默认提供 copy constructor 和 assignment operator，因此除非明确禁止，否则 class 总是可以作为标准库的元素类型——尽管程序可以编译通过，但是隐藏了资源管理方面的 bug。
>
>因此，在写一个 class 的时候，先让它继承 boost::noncopyable，几乎总是正确的。
>
>在现代 C++ 中，一般不需要自己编写 copy constructor 或 assignment operator，因为只要每个数据成员都具有值语义的话，编译器自动生成的 member-wise copying&assigning 就能正常工作；如果以 smart ptr 为成员来持有其他对象，那么就**能自动启用或禁用 copying&assigning**。例外：编写 HashMap 这类底层库时还是需要自己实现 copy control。

* 只有值语义才能放入标准库容器，  对象语义要借助智能指针将其转化为值语义， 再放入标准库

  （如果是对象语义，直接禁止其拷贝。如果是值语义，只要每个数据成员都具有值语义，编译器自动合成的 拷贝构造和拷贝赋值就可以正确工作？    （个人理解，不对再改） ）。
  
  