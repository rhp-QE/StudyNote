## Foundation

### Communication Patterns

消息的发送者： ableView ,  被观察者

消息的接受者： tableView的delegate ， 观察者

#### kvo

合适的使用场景

* 只关心 消息发送者的 Values 的变化
* 消息的接收者要知道消息发送者。
* 消息者清楚消息发送者的生命周期， 以便在消息发送者死亡前注销观察。
* 通行的信道 可以是一对多， 多个观察者可以观察同一个对象。

```
KVOController
1) 观察者先销毁， 被观察者发送消息
```



---



#### Notification

特点

* 发送者不知道接收者 接收者不知道发送者。 适合耦合度非常松散的模块间的通信。
* 单向通信。因为发送者和接收着 互相不知道， 因此无法对 notifacation 进行回信。

---



#### Delegate

* 发送者需要了解接收者。但是发送者只需要知道接收者符合某个协议即可，耦合性降低。
* 双向通信。发送者可以 以委托函数参数的形式向接收者传递附加信息， 消息的接收者可以 以委托函数的返回值的形式向发送者传递恢复信息。

当我们需要在**两个具体的对象**间传递消息， 并且这两个对象在整体结构中**距离较近**。

---



#### Block

与delegate 相比， 在下面这种场景下有优势

* 首选，接受者调用消息发送者的函数，然后消息发送者执行完任务后通知接收者，接收者再接着执行某项任务。（像callBack?）.   如果使用delegate 那么**接收者调用发送者的逻辑**和**接收者收到发送者通知后接着执行某项任务的逻辑**是分开的。 如果使用block, 则可以把代码逻辑聚合在一起。  比如：dataManger 向  request 请求数据，请求到数据后dataManger 对数据的处理逻辑。

---



#### Responder Chain

* 消息的接收者和发送者互相不清楚对方的存在。
* 只能沿着调用 responder chain 传递
* 适合在整体结构中相距比较远，且最好是祖先 关系的节点间通信。

----



![](/Users/bytedance/Desktop/StudyNote/OC/images/UML1.jpg)









## 并发编程



​        编写多线程程序时， 某些代码块是否在同一个线程内执行。 特别是当我们使用第三方库的时候，我们注册的回调函数极有可能在第三方库开启的线程内执行。

​        借鉴muduo 和iOS  的 runLoop,  当有些操作必须在某个线程内执行时，我们就把这些操作 push 到该线程的任务队列里面。

---

---





#### 使用低阶API 进行并发编程

* 使用互斥器、条件变量 等工具，通常在设计比较底层的东西时用的多



* 比如编写一个底层的并发队列。就要使用到底层的API。 

  使用互斥器来保护队列的读写，条件变量来通知 线程，队列非空？ 满？   

  并发队列只涉及到共享数据的修改操作。  
  别的情况下，比如同时存在对共享数据的读、写操作？

  （读-写 、 写-读、 读-读 、 写-写）

  写写： 不可并行化

  读读 ：并行化

  写读： 

  ---

  *  方案1: 使用读写锁，使读写分离，读读共存。

    此时存在一个问题。 在  读-写 情况下。如果在读操作时做了一些非常耗时，甚至阻塞的操作，那么写操作就会一直等待，等待时间是没有上限的（比如在读操作内调用了一个回调函数，回调函数去请求网络数据等等，我们没法预测执行回调函数所需要的时间）。  同样，写操作也可能让读操作陷入无上限的等待中。

    *   此时常用的一个解决方案是：写时复制。 这样就可以使得 读-写 可并行。
      大体思路：  对共享数据加一个访问计数器，并用一个互斥器来保护访问计数器。   当读操作到来时，在互斥器的保护范围内，对访问计数器加一。 然后访问数据，访问完后访问计数器减减。   当写操作到来时，在互斥器的保护范围内，访问计数器加一，如果访问计数器的值为一，则直接修改，否则，将数据拷贝后再做修改。（在C++中，借助智能指针 可以轻松实现）。
      可以看出，读操作不会阻塞写操作，因为读操作在互斥区内只修改了访问计数器。写操作都是在互斥区域内完成，但是写操作都是可以保证只是修改数组，其调用是有时间上限的，不会阻塞。


      思考：  能不能  读时复制。 
      不能！！！    因为 对同块内存。读写是互斥的， 写时复制，也只是将原来的那块复制一份，在新的一份上做修改， 复制的过程也可以看作是读的过程，不会和之前并非读产生冲动。 既然复制是读的过程，那么读时复制是没有意义的？ 并且 写时 读 是禁止的！！





#### 使用高级API 进行并发编程

使用并发队列和同步队列来进行并发编程。



#### 什么时候需要将我们的 class 设计为 线程安全的？



#### 什么时候使用高级API, 什么时候使用 低级API?





* 定义 textMessageCell. imageMessageCell
* 定义 messageCellModel
* 定义 messageModel.   用于数据存储，//只有要展示的信息， 
  文字，图片，头像， 谁的,  类型

* 用于接收网络转发，和内存读取的model 还要另外计算





### 懒加载 VS  主动创建

* 主动创建 可以定制参数，自己明确创建时机
* 懒加载 不可以定制参数，什么时候使用，什么时候创建













* 设计一个线程安全的类
  * 这个类是否是多个线程可见？  主要是从数据流动来看。从业务数据的流动来分析。





* MVVM
* V 与VM绑定， 与M 解绑。  在VM里进行双向绑定，V 改变通知M。M改变通知V。    VC 功能解放，仅仅做 初始化操作。



* MVC
  VC 看作V 和 M的容器





阅读代码由上往下，抽丝剥茧，越往下，节点功能越复杂，往上节点功能单一。













